<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AMC Uart reader</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
* {
    color: white;
    font-family: Arial, Helvetica, sans-serif;
    text-align: left;
    margin: 0;
    padding: 0;
}

body {
    background-color: #2A2A2A;
    display: flex;
    justify-content: space-between;
    height: 100vh;
    margin: 0;
    overflow: hidden;
}

main {
    width: 75%;
    background-color: #333;
    padding: 20px;
    overflow-y: auto;
}

section {
    background-color: #333;
    padding: 10px;
    border-radius: 5px;
}

#lewy {
    width: 20%;
    background-color: #2A2A2A;
    padding: 20px;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

header {
    background-color: #5C5C5C;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 15px;
    text-align: center;
}

h1 {
    font-size: 22px;
    text-align: center;
}

#gora, #dol {
    height: 45%;
}

button {
    background-color: #5C5C5C;
    color: white;
    padding: 10px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    margin-top: 10px;
}

button:hover {
    background-color: #777;
}

#status {
    margin-top: 10px;
    font-size: 18px;
}

#deviceDetails {
    background-color: #444;
    border-radius: 5px;
    padding: 15px;
    max-width: 100%;
    overflow: hidden;
    height: 90%;
}


#deviceDetails div {
    margin-bottom: 50px;
}

#deviceDetails strong {
    font-size: 16px;
}

#deviceDetails p {
    font-size: 14px;
    color: #ccc;
}

#deviceDetails select, #deviceDetails input {
    width: 100%;
    padding: 8px;
    background-color: #5C5C5C;
    border: none;
    border-radius: 5px;
    margin-bottom: 10px;
}

#deviceDetails button {
    background-color: #777;
    width: 100%;
}

#deviceDetails button:hover {
    background-color: #888;
}

.btn-circle {
      width: 60px;
      height: 60px;
      padding: 0;
      border-radius: 50%;
      background-color: #ccc;
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color 0.3s;
    }

    .btn-circle:hover {
      background-color: #bbb;
    }

    .arrow {
      width: 20px;
      height: 20px;
      border-top: 2px solid black;
      border-right: 2px solid black;
      transform: rotate(45deg);
    }

/* ===== Logger UI ===== */
#loggerWrap{ margin-top:10px; }
#loggerHeader{ display:flex; gap:10px; align-items:center; justify-content:space-between; margin-top:10px; }
#logger{
  background:#111;
  border:1px solid #444;
  border-radius:5px;
  padding:10px;
  height:180px;
  overflow-y:auto;
  font-family:monospace;
  font-size:12px;
  line-height:1.35;
}
.log-info{color:#9cdcfe;}
.log-ok{color:#4ec9b0;}
.log-warn{color:#dcdcaa;}
.log-err{color:#f44747;}
.smallBtn{ font-size:12px; padding:6px 10px; margin-top:0; }

</style>
</head>
<body>
  <section id="lewy">
    <section id="gora">
      <header>
        <h1>Łączenie z portem USB</h1>
      </header>
      <button id="connectButton">Połącz z portem</button>
      <p id="status">Status: Brak połączenia</p>

      <div id="loggerWrap">
        <div id="loggerHeader">
          <strong>Logi (na telefonie)</strong>
          <button id="clearLog" class="smallBtn">Wyczyść</button>
        </div>
        <div id="logger"></div>
      </div>
    </section>
    
    <section id="dol">
      <header>
        <h1>Lista urządzeń</h1>
        <button id="refresh">
          <i class="fas fa-sync-alt"></i> Odśwież
        </button>
      </header>
        <p id="urzadzenie"></p>
    </section>
  </section>

  <main>
    <header>
      <h1>Detale urządzenia</h1>
    </header>
    <section id="deviceDetails">
      <div>
        <strong>Device Type:</strong>
        <p id="deviceType"></p>
      </div>
      <div>
        <strong>Nazwa urządzenia:</strong>
        <p id="deviceName"></p>
      </div>
      <div>
        <strong>UID:</strong>
        <p id="uid"></p>
      </div>
      <div>
        <strong>ID/Modbus ID:</strong>
        <p id="deviceId"></p>
      </div>
      <hr>
      <div>
        <strong>Nowa nazwa urządzenia:</strong>
        <input type="text" id="newDeviceName" placeholder="Wprowadź nową nazwę urządzenia" />
      </div>
      <div>
        <strong>Nowe ID:</strong>
        <input type="number" id="newDeviceId" placeholder="Wprowadź nowe ID" />
      </div>
      <div>
        <strong>Modbus RTU Baud Rate:</strong>
        <select id="modbusBaudRate">
          <option value="4800">4800</option>
          <option value="7200">7200</option>
          <option value="9600">9600</option>
          <option value="14400">14400</option>
          <option value="19200">19200</option>
          <option value="28800">28800</option>
          <option value="33600">33600</option>
          <option value="38400">38400</option>
          <option value="57600">57600</option>
          <option value="115200">115200</option>
          <option value="50000">50000</option>
          <option value="100000">100000</option>
          <option value="150000">150000</option>
        </select>
      </div>
      <button id="updateDeviceButton">Zaktualizuj urządzenie</button>

    </section>
  </main>

  <!-- WebUSBSerial: WebSerial-like API na WebUSB (Android + USB-UART) -->
  <script src="https://cdn.jsdelivr.net/gh/NielsLeenheer/WebUSBSerial@master/dist/webusb-serial.umd.js"></script>

  <script>
let port = null;
let writer = null;
let reader = null;

// ===== DIAGNOSTYKA Web Serial (pomaga ustalić czemu na telefonie nie ma prompta) =====
console.group("=== Web Serial DIAGNOSTYKA ===");
console.log("User-Agent:", navigator.userAgent);
console.log("isSecureContext:", window.isSecureContext);
console.log("location.protocol:", location.protocol);
console.log("navigator.serial exists:", "serial" in navigator);
console.log("navigator.serial value:", navigator.serial);
console.groupEnd();
// ================================================================================


let deviceId = "";
let deviceName = "";
let deviceUID = "";

const connectButton = document.getElementById("connectButton");
const refreshButton = document.getElementById("refresh");
const statusText = document.getElementById("status");
const lista = document.getElementById("urzadzenie");
const deviceType = document.getElementById("deviceType");
const deviceNameHTML = document.getElementById("deviceName");
const deviceIdHTML = document.getElementById("deviceId");
const UID = document.getElementById("uid");

// ===== Logger UI (działa bez DevTools, idealne na telefon) =====
const loggerEl = document.getElementById("logger");
const clearLogBtn = document.getElementById("clearLog");

function uiLog(msg, level = "info") {
  if (!loggerEl) return;
  const line = document.createElement("div");
  const cls = level === "ok" ? "log-ok" : level === "warn" ? "log-warn" : level === "err" ? "log-err" : "log-info";
  line.className = cls;
  const ts = new Date().toLocaleTimeString();
  line.textContent = `[${ts}] ${msg}`;
  loggerEl.appendChild(line);
  loggerEl.scrollTop = loggerEl.scrollHeight;
}

if (clearLogBtn) {
  clearLogBtn.addEventListener("click", () => {
    loggerEl.innerHTML = "";
    uiLog("Log wyczyszczony", "ok");
  });
}

// Podpinamy console do loggera (zostawiamy też normalną konsolę)
const _cl = console.log.bind(console);
const _ce = console.error.bind(console);
const _cw = console.warn.bind(console);
console.log = (...args) => { _cl(...args); uiLog(args.map(String).join(" "), "info"); };
console.warn = (...args) => { _cw(...args); uiLog(args.map(String).join(" "), "warn"); };
console.error = (...args) => { _ce(...args); uiLog(args.map(String).join(" "), "err"); };

uiLog("Start strony", "ok");
uiLog("isSecureContext=" + window.isSecureContext);
uiLog("navigator.usb=" + ("usb" in navigator));
uiLog("WebUSBSerial=" + (typeof WebUSBSerial !== "undefined"));
// ==============================================================

const wCRCTable = [
  0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
  0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
  0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
  0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
  0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
  0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
  0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
  0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
  0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
  0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
  0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
  0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
  0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
  0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
  0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
  0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
  0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
  0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
  0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
  0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
  0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
  0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
  0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
  0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
  0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
  0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
  0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
  0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
  0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
  0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
  0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
  0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
];

connectButton.addEventListener("click", async () => {
  console.group("=== Kliknięto Połącz (WebUSB) ===");
  console.log("isSecureContext:", window.isSecureContext);
  console.log("navigator.usb:", "usb" in navigator);
  console.log("WebUSBSerial:", typeof WebUSBSerial !== "undefined");
  console.log("port before:", port);
  console.groupEnd();

  if (!("usb" in navigator) || typeof WebUSBSerial === "undefined") {
    statusText.textContent = "Status: Brak wsparcia WebUSB w tej przeglądarce";
    console.error("Brak WebUSB lub WebUSBSerial. Użyj Chrome/Edge (Chromium) i HTTPS.");
    return;
  }

  if (port) {
    keepReading = false;
    try {
      if (reader) await reader.cancel();
      if (writer) await writer.close();
      await port.close();
    } catch (err) {
      console.error("Błąd podczas rozłączania:", err);
    }
    port = null;
    writer = null;
    reader = null;
    connectButton.textContent = "Połącz z portem";
    statusText.textContent = "Status: Rozłączono";
    return;
  }

  try {
    console.log("Wywołuję WebUSBSerial.requestPort() (filtr FTDI VID=0x0403)");
    port = await WebUSBSerial.requestPort({
      filters: [{ usbVendorId: 0x0403 }]
    });
    console.log("Wybrano urządzenie:", port?.device?.productName || "(brak nazwy)");
    if (port?.device) {
      console.log(
        "VID=0x" + port.device.vendorId.toString(16) +
        " PID=0x" + port.device.productId.toString(16)
      );
    }

    await port.open({ baudRate: 9600 });
    writer = port.writable.getWriter();

    if (port.readable) {
      reader = port.readable.getReader();
      keepReading = true;
      statusText.textContent = "Status: Połączono (WebUSB)";
      connectButton.textContent = "Rozłącz";
      await Id();
    } else {
      console.error("Port nie jest dostępny do czytania.");
      statusText.textContent = "Status: Port niedostępny (readable=false)";
    }
  } catch (err) {
    console.error("Błąd połączenia:", err);
    statusText.textContent = "Status: Błąd połączenia";
  }
});



function calculateCRC16(data) {
  let crc = 0xFFFF;
  for (let i = 0; i < data.length; i++) {
    let tableIndex = (crc ^ data[i]) & 0xFF;
    crc = ((crc >> 8) ^ wCRCTable[tableIndex]) & 0xFFFF;
  }
  return [crc & 0xFF, (crc >> 8) & 0xFF];
}

let keepReading = true;

let receivedData = [];

let dynamicTimeout = 20000;
const maxTimeout = 60000;
let timeoutIncrement = 5000;

async function readLoop() {
  receivedData = [];

  try {
    let expectedBytes = 0;
    let receivedBytes = 0;

    let timeoutTimer = setTimeout(() => {
      keepReading = false;
    }, dynamicTimeout);

    while (port.readable && keepReading) {
      const { value, done } = await reader.read();
      if (done) break;

      if (value) {
        receivedData = [...receivedData, ...value];
        receivedBytes = receivedData.length;

        const hexString = [...receivedData]
          .map(b => b.toString(16).padStart(2, '0'))
          .join(' ')
          .toUpperCase();

        if (receivedData.length >= 3) {
          const byteCount = receivedData[2];
          expectedBytes = 3 + byteCount + 2;

          if (receivedBytes >= expectedBytes) {
            keepReading = false;
            break;
          }
        }
      }
    }

    clearTimeout(timeoutTimer);

    if (receivedData.length > 0) {
      const hexData = receivedData.map(b => b.toString(16).padStart(2, '0')).join(' ').toUpperCase();
      return hexData;
    } else {
      dynamicTimeout = Math.min(dynamicTimeout + timeoutIncrement, maxTimeout);
      return null;
    }

  } catch (err) {
    console.error("Błąd odbioru:", err);
    throw err;
  }
}

function handleDeviceId(receivedData) {
  if (receivedData.length >= 5) {
    deviceId = receivedData[4].toString(16).padStart(2, '0').toUpperCase();
    if (deviceId) {
    }
  }
}

async function Id() {
  try {
    const hex = "FF 03 00 00 00 01 91 D4";
    const bytes = hex.replace(/\s+/g, '').match(/.{1,2}/g)?.map(b => parseInt(b, 16));
    if (bytes) {
      const data = new Uint8Array(bytes);
      if (writer) {
        await writer.write(data);

        keepReading = true;
        let responseData = await readLoop();
        if (!responseData) {
          responseData = await readLoop();
        }

        if (responseData) {
          const responseBytes = responseData.split(' ').length;
          if (responseBytes >= 7) {
            handleDeviceId(receivedData);
          }
        }
      }
    }
  } catch (err) {
    console.error("Błąd wysyłania lub odbierania:", err);
  }
}

async function readHoldingRegister(deviceId, startingAddressHigh, startingAddressLow, registersNumber) {
  try {
    let id = parseInt(deviceId, 16);
    let functionCode = 0x03;

    let startingAddressHighByte = startingAddressHigh;
    let startingAddressLowByte = startingAddressLow;
    let numberOfRegistersHighByte = (registersNumber >> 8) & 0xFF;
    let numberOfRegistersLowByte = registersNumber & 0xFF;

    let request = [
      id,
      functionCode,
      startingAddressHighByte,
      startingAddressLowByte,
      numberOfRegistersHighByte,
      numberOfRegistersLowByte
    ];

    const crc = calculateCRC16(request);
    request.push(crc[0]);
    request.push(crc[1]);

    const hexRequest = request.map(byte => byte.toString(16).padStart(2, '0')).join(' ').toUpperCase();

    if (writer) {
      const data = new Uint8Array(request);
      await writer.write(data);

      keepReading = true;
      let response = await readLoop();
      if (response) {
        return response;
      } else {
        return null;
      }
    }
  } catch (error) {
    console.error("Błąd podczas tworzenia zapytania Modbus:", error);
    throw error;
  }
}

function hexToAscii(hexString) {
  let str = '';
  hexString = hexString.replace(/\s+/g, '').toUpperCase();
  hexString = hexString.slice(0, -3);

  for (let i = 0; i < hexString.length; i += 2) {
    const hex = hexString.substr(i, 2);
    const decimal = parseInt(hex, 16);

    if (decimal >= 32 && decimal <= 126) {
      str += String.fromCharCode(decimal); 
    }
  }

  let swappedStr = '';
  for (let i = 0; i < str.length - 1; i++) {
    swappedStr += str[i + 1];
    swappedStr += str[i];
    i++;
  }

  if (str.length % 2 !== 0) {
    swappedStr += str[str.length - 1];
  }

  return swappedStr;
}

function processUid(hexString) {
  hexString = hexString.replace(/\s+/g, '').toUpperCase();
  let hexArray = hexString.match(/.{2}/g);
  hexArray.splice(0, 3);
  hexArray.splice(-2, 2);

  let swappedStr = '';
  for (let i = 0; i < hexArray.length - 1; i++) {
    swappedStr += hexArray[i + 1];
    swappedStr += hexArray[i];
    i++;
  }

  if (hexArray.length % 2 !== 0) {
    swappedStr += hexArray[hexArray.length - 1];
  }

  let result = swappedStr.match(/.{2}/g).join(':');

  return result;
}

lista.addEventListener("click", (event) => {
  if (event.target && event.target.nodeName === "P") {
    deviceType.innerHTML = event.target.textContent;
    deviceNameHTML.innerHTML = event.target.textContent;
    deviceIdHTML.innerHTML = deviceId;
    deviceUID = processUid(deviceUID);
    UID.innerHTML = deviceUID;
  }
});

refreshButton.addEventListener("click", async () => {
  readHoldingRegister(deviceId, 0x00, 0x08, 6).then((response) => {
    deviceName = response; 
    deviceName = hexToAscii(deviceName);
    lista.innerHTML = deviceName;

    readHoldingRegister(deviceId, 0x00, 0x01, 6).then((response) => {
      deviceUID = response;
    }).catch((err) => {
      console.error("Błąd podczas wywoływania readHoldingRegister:", err);
    })
  }).catch((err) => {
    console.error("Błąd podczas wywoływania readHoldingRegister:", err);
  })
});

</script>
</body>
</html>
